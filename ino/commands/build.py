# -*- coding: utf-8; -*-

import re
import os.path
import inspect
import subprocess
import jinja2

from jinja2.runtime import StrictUndefined

import ino.filters

from ino.commands.base import Command
from ino.utils import SpaceList, list_subdirs
from ino.exc import Abort


class Build(Command):

    name = 'build'

    def setup_arg_parser(self, parser):
        self.e.add_board_model_arg(parser)
        self.e.add_arduino_dist_arg(parser)

    def discover(self):
        self.e.find_arduino_dir('arduino_core_dir', 
                                ['hardware', 'arduino', 'cores', 'arduino'], 
                                ['WProgram.h'], 
                                'Arduino core library')

        self.e.find_arduino_dir('arduino_libraries_dir', ['libraries'],
                                human_name='Arduino standard libraries')

        self.e.find_tool('cc', ['avr-gcc'], human_name='avr-gcc')
        self.e.find_tool('cxx', ['avr-g++'], human_name='avr-g++')
        self.e.find_tool('ar', ['avr-ar'], human_name='avr-ar')
        self.e.find_tool('objcopy', ['avr-objcopy'], human_name='avr-objcopy')

    def setup_flags(self, board):
        mcu = '-mmcu=' + board['build']['mcu']
        self.e['cflags'] = SpaceList([
            mcu,
            '-ffunction-sections',
            '-fdata-sections',
            '-g',
            '-Os', 
            '-w',
            '-DF_CPU=' + board['build']['f_cpu'],
            '-DARDUINO=22',
            '-I' + self.e['arduino_core_dir'],
        ])

        self.e['cxxflags'] = SpaceList(['-fno-exceptions'])
        self.e['elfflags'] = SpaceList(['-Os', '-Wl,--gc-sections', mcu])

        self.e['names'] = {
            'obj': '%s.o',
            'lib': 'lib%s.a',
        }

    def create_jinja(self):
        self.jenv = jinja2.Environment(
            undefined=StrictUndefined, # bark on Undefined render
            extensions=['jinja2.ext.do'])

        # inject @filters from ino.filters
        for name, f in inspect.getmembers(ino.filters, lambda x: getattr(x, 'filter', False)):
            self.jenv.filters[name] = f

        # inject globals
        self.jenv.globals['e'] = self.e
        self.jenv.globals['SpaceList'] = SpaceList

    def render_template(self, source, target, **ctx):
        template = os.path.join(os.path.dirname(__file__), '..', '..', 'make', source)
        with open(template) as f:
            template = self.jenv.from_string(f.read())

        contents = template.render(**ctx)
        out_path = os.path.join(self.e['build_dir'], target)
        with open(out_path, 'wt') as f:
            f.write(contents)

        return out_path

    def recursive_inc_lib_flags(self, libdirs):
        flags = SpaceList()
        for d in libdirs:
            flags.append('-I' + d)
            flags.extend('-I' + subd for subd in list_subdirs(d, recursive=True, exclude=['examples']))
        return flags

    def scan_dependencies(self):
        libdirs = list_subdirs(self.e.lib_dir) + list_subdirs(self.e.arduino_libraries_dir)
        makefile = self.render_template('Makefile.deps.jinja', 'Makefile.deps',
                                        inc_flags=self.recursive_inc_lib_flags(libdirs))

        subprocess.call(['make', '-f', makefile, 'all'])

        # search for dependencies on libraries
        # for this scan dependency file generated by make
        # with regexes to find entries that start with
        # libraries dirname
        re_template = ur'^\s+(?P<libdir>{dirname}{slash}([^{slash}])+){slash}'
        re_compile = lambda dirname: re.compile(
            re_template.format(dirname=re.escape(dirname),
                               slash=re.escape(os.path.sep)))

        local_re = re_compile(self.e.lib_dir)
        dist_re = re_compile(self.e.arduino_libraries_dir)

        used_libs = set()
        with open(os.path.join(self.e['build_dir'], 'dependencies.d')) as f:
            for line in f:
                match = local_re.match(line) or dist_re.match(line)
                if match:
                    used_libs.add(match.group('libdir'))

        self.e['extra_libs'] = list(used_libs)
        self.e['cflags'].extend(self.recursive_inc_lib_flags(used_libs))

    def build(self):
        makefile = self.render_template('Makefile.jinja', 'Makefile')
        subprocess.call(['make', '-f', makefile, 'all'])

    def run(self, args):
        self.discover()
        self.setup_flags(args.board_model)
        self.create_jinja()
        self.scan_dependencies()
        self.build()
